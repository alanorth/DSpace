/**
 * The contents of this file are subject to the license and copyright
 * detailed in the LICENSE and NOTICE files at the root of the source
 * tree and available online at
 *
 * http://www.dspace.org/license/
 */
package org.dspace.app.mediafilter;

import org.dspace.authorize.AuthorizeException;
import org.dspace.authorize.AuthorizeManager;
import org.dspace.content.*;
import org.dspace.core.ConfigurationManager;
import org.dspace.core.Constants;
import org.dspace.core.Context;
import org.dspace.eperson.Group;

import java.io.InputStream;
import java.sql.SQLException;
import java.util.ArrayList;
import java.util.List;

/**
 * Public interface for any class which transforms or converts content/bitstreams 
 * from one format to another.  This interface should be implemented by any class
 * which defines a "filter" to be run by the MediaFilterManager.
 */
/* BEGIN Atmire change */
public abstract class FormatFilter {

    private static final List<String> publicFiltersClasses = new ArrayList<>();

    static {
        String publicPermissionFilters = ConfigurationManager.getProperty("filter.org.dspace.app.mediafilter.publicPermission");
        if(publicPermissionFilters != null) {
            String[] publicPermisionFiltersArray = publicPermissionFilters.split(",");
            for(String filter : publicPermisionFiltersArray) {
                publicFiltersClasses.add(filter.trim());
            }
        }
    }

    /**
     * Get a filename for a newly created filtered bitstream
     *
     * @param sourceName name of source bitstream
     * @return filename generated by the filter - for example, document.pdf
     * becomes document.pdf.txt
     */
    public abstract String getFilteredName(String sourceName);

    /**
     * @return name of the bundle this filter will stick its generated
     * Bitstreams
     */
    public abstract String getBundleName();

    /**
     * @return name of the bitstream format (say "HTML" or "Microsoft Word")
     * returned by this filter look in the bitstream format registry or
     * mediafilter.cfg for valid format strings.
     */
    public abstract String getFormatString();

    /**
     * @return string to describe the newly-generated Bitstream's - how it was
     * produced is a good idea
     */
    public abstract String getDescription();

    /**
     * @param source input stream
     * @return result of filter's transformation, written out to a bitstream
     */
    public abstract InputStream getDestinationStream(InputStream source)
            throws Exception;

    /**
     * Perform any pre-processing of the source bitstream *before* the actual
     * filtering takes place in MediaFilterManager.processBitstream().
     * <p/>
     * Return true if pre-processing is successful (or no pre-processing
     * is necessary).  Return false if bitstream should be skipped
     * for any reason.
     *
     * @param c      context
     * @param item   item containing bitstream to process
     * @param source source bitstream to be processed
     * @return true if bitstream processing should continue,
     * false if this bitstream should be skipped
     */
    public abstract boolean preProcessBitstream(Context c, Item item, Bitstream source)
            throws Exception;

    /**
     * Perform any post-processing of the generated bitstream *after* this
     * filter has already been run.
     * <p/>
     * Return true if pre-processing is successful (or no pre-processing
     * is necessary).  Return false if bitstream should be skipped
     * for some reason.
     *
     * @param c                  context
     * @param item               item containing bitstream to process
     * @param generatedBitstream the bitstream which was generated by
     *                           this filter.
     */
    public abstract void postProcessBitstream(Context c, Item item, Bitstream generatedBitstream)
            throws Exception;


    /**
     * processBitstream is a utility class that calls the virtual methods
     * from the current MediaFilter class.
     * It scans the bitstreams in an item, and decides if a bitstream has
     * already been filtered, and if not or if overWrite is set, invokes the
     * filter.
     *
     * @param c      context
     * @param item   item containing bitstream to process
     * @param source source bitstream to process
     * @return true if new rendition is created, false if rendition already
     * exists and overWrite is not set
     */
    public boolean processBitstream(Context c, Item item, Bitstream source, boolean isQuiet)
            throws Exception {
        //do pre-processing of this bitstream, and if it fails, skip this bitstream!
        if (!preProcessBitstream(c, item, source)) {
            return false;
        }

        boolean overWrite = MediaFilterManager.isForce;

        // get bitstream filename, calculate destination filename
        String newName = getFilteredName(source.getName());

        Bitstream existingBitstream = null; // is there an existing rendition?
        Bundle targetBundle = null; // bundle we're modifying

        Bundle[] bundles = item.getBundles(getBundleName());

        // check if destination bitstream exists
        if (bundles.length > 0) {
            // only finds the last match (FIXME?)
            for (int i = 0; i < bundles.length; i++) {
                Bitstream[] bitstreams = bundles[i].getBitstreams();

                for (int j = 0; j < bitstreams.length; j++) {
                    if (bitstreams[j].getName().equals(newName)) {
                        targetBundle = bundles[i];
                        existingBitstream = bitstreams[j];
                    }
                }
            }
        }

        // if exists and overwrite = false, exit
        if (!overWrite && (existingBitstream != null)) {
            if (!isQuiet) {
                System.out.println("SKIPPED: bitstream " + source.getID()
                        + " (item: " + item.getHandle() + ") because '" + newName + "' already exists");
            }

            return false;
        }

        InputStream destStream;
        try {
            System.out.println("File: " + newName);
            destStream = getDestinationStream(source.retrieve());
            if (destStream == null) {
                if (!isQuiet) {
                    System.out.println("SKIPPED: bitstream " + source.getID()
                            + " (item: " + item.getHandle() + ") because filtering was unsuccessful");
                }

                return false;
            }
        } catch (OutOfMemoryError oome) {
            System.out.println("!!! OutOfMemoryError !!!");
            return false;
        }

        // create new bundle if needed
        if (bundles.length < 1) {
            targetBundle = item.createBundle(getBundleName());
        } else {
            // take the first match
            targetBundle = bundles[0];
        }

        Bitstream b = targetBundle.createBitstream(destStream);

        // Now set the format and name of the bitstream
        b.setName(newName);
        b.setSource("Written by FormatFilter " + getClass().getName() +
                " on " + DCDate.getCurrent() + " (GMT).");
        b.setDescription(getDescription());

        // Find the proper format
        BitstreamFormat bf = BitstreamFormat.findByShortDescription(c,
                getFormatString());
        b.setFormat(bf);
        b.update();

        //Inherit policies from the source bitstream
        //(first remove any existing policies)
//        AuthorizeManager.removeAllPolicies(c, b);
//        AuthorizeManager.inheritPolicies(c, source, b);
        setPolicies(c, source, b);

        // fixme - set date?
        // we are overwriting, so remove old bitstream
        if (existingBitstream != null) {
            targetBundle.removeBitstream(existingBitstream);
        }

        if (!isQuiet) {
            System.out.println("FILTERED: bitstream " + source.getID()
                    + " (item: " + item.getHandle() + ") and created '" + newName + "'");
        }

        //do post-processing of the generated bitstream
        postProcessBitstream(c, item, b);

        return true;
    }

	protected void setPolicies(Context c, DSpaceObject source, Bitstream b) throws SQLException, AuthorizeException {
		AuthorizeManager.removeAllPolicies(c, b);

		AuthorizeManager.inheritPolicies(c, source, b);

		if (b.getName().endsWith(".jpg")) {
			Group anon = Group.find(c, 0);
			boolean needsAnon = true;

			for (Group g : AuthorizeManager.getAuthorizedGroups(c, b, Constants.READ)) {
				if (g.getID() == 0) {
					needsAnon = false;
				}
			}

			if (needsAnon) {
				AuthorizeManager.addPolicy(c, b, Constants.READ, anon);
			}
		}
	}
}
/* END Atmire change */

